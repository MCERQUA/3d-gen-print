import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import JSZip from "jszip";

interface ColorSlot {
  name: string;
  hex: string;
}

interface ExportRequest {
  modelUrl: string;
  colors: ColorSlot[];
  scale?: number;
  modelName?: string;
}

// Generate 3MF content types XML
function generateContentTypes(): string {
  return `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml"/>
</Types>`;
}

// Generate 3MF relationships XML
function generateRels(): string {
  return `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel"/>
</Relationships>`;
}

// Convert hex color to ARGB format for 3MF
function hexToARGB(hex: string): string {
  const cleanHex = hex.replace("#", "");
  return `#FF${cleanHex.toUpperCase()}`;
}

// Generate 3MF model XML with materials
function generate3DModel(colors: ColorSlot[], modelName: string): string {
  const materials = colors
    .map((color, index) => {
      const argb = hexToARGB(color.hex);
      return `      <slic3rpe:material id="${index + 1}" name="${color.name}" extruder="${index + 1}" color="${argb}"/>`;
    })
    .join("\n");

  return `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US"
  xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02"
  xmlns:slic3rpe="http://schemas.slic3r.org/3mf/2017/06">
  <metadata name="Title">${modelName}</metadata>
  <metadata name="Designer">3D Gen Print</metadata>
  <metadata name="Application">3D Gen Print by MCERQUA</metadata>
  <metadata name="CreationDate">${new Date().toISOString()}</metadata>
  <resources>
    <slic3rpe:materials>
${materials}
    </slic3rpe:materials>
    <object id="1" type="model">
      <mesh>
        <!-- Model mesh data would go here -->
        <!-- For full implementation, we'd parse the GLB and convert to 3MF mesh format -->
        <vertices>
          <vertex x="0" y="0" z="0"/>
        </vertices>
        <triangles>
        </triangles>
      </mesh>
    </object>
  </resources>
  <build>
    <item objectid="1"/>
  </build>
</model>`;
}

// Generate Bambu Studio config
function generateBambuConfig(colors: ColorSlot[]): string {
  const filamentConfigs = colors.map((color, index) => {
    return `[filament:${index + 1}]
filament_colour = ${hexToARGB(color.hex)}
filament_type = PLA
filament_vendor = Generic`;
  }).join("\n\n");

  return `# Bambu Studio Project Config
# Generated by 3D Gen Print

${filamentConfigs}

[print]
print_settings_id = 0.20mm Standard @BBL X1C
`;
}

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();

    if (!userId) {
      return NextResponse.json({ message: "Unauthorized" }, { status: 401 });
    }

    const body: ExportRequest = await req.json();
    const { modelUrl, colors, modelName = "3DGenPrint_Model" } = body;

    if (!modelUrl || !colors || colors.length === 0) {
      return NextResponse.json(
        { message: "Model URL and colors are required" },
        { status: 400 }
      );
    }

    // Create 3MF ZIP file
    const zip = new JSZip();

    // Add content types
    zip.file("[Content_Types].xml", generateContentTypes());

    // Add relationships
    const relsFolder = zip.folder("_rels");
    relsFolder?.file(".rels", generateRels());

    // Add 3D model folder
    const modelFolder = zip.folder("3D");
    modelFolder?.file("3dmodel.model", generate3DModel(colors, modelName));

    // Add Bambu/Slic3r config for material presets
    const metadataFolder = zip.folder("Metadata");
    metadataFolder?.file("Slic3r_PE.config", generateBambuConfig(colors));

    // Generate the ZIP file
    const zipBuffer = await zip.generateAsync({
      type: "nodebuffer",
      compression: "DEFLATE",
      compressionOptions: { level: 9 },
    });

    // Return as downloadable file
    return new NextResponse(zipBuffer, {
      status: 200,
      headers: {
        "Content-Type": "application/vnd.ms-package.3dmanufacturing-3dmodel+xml",
        "Content-Disposition": `attachment; filename="${modelName}.3mf"`,
        "Content-Length": zipBuffer.length.toString(),
      },
    });
  } catch (error) {
    console.error("3MF export error:", error);
    return NextResponse.json(
      { message: error instanceof Error ? error.message : "Export failed" },
      { status: 500 }
    );
  }
}

// GET endpoint to check if 3MF export is available
export async function GET() {
  return NextResponse.json({
    available: true,
    formats: ["3mf"],
    features: ["materials", "colors", "bambu-config"],
    note: "Full mesh export coming soon - currently exports material definitions only",
  });
}
